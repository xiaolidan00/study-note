# 只会用 2005 年的 Git 老命令？这 7 个 Git 新命令，很实用！

https://mp.weixin.qq.com/s/ziGlcEH5AL_HE4IiUaXfZw

# 深入理解浏览器的缓存机制

https://www.jianshu.com/p/54cc04190252

# 前端工匠

https://github.com/ljianshu/Blog

# 9 个移动端触摸事件优化,响应速度提升 95%

https://mp.weixin.qq.com/s/xRFukIL0U84it_364AhymA

# 跨平台解决方案的技术分析

https://mp.weixin.qq.com/s/3a10-izcV3POMikfh1IILw

## Web 渲染方案

Web 渲染方案主要是使用原生 WebView 控件渲染 HTML 页面，并在原生应用中定义可供 H5 页面访问原生部分能力的接口 JSBridge，从而实现 H5 和 Native 双向通信，也使得 H5 的能力向端侧进一步扩展。
Web 渲染方案本质上是依托原生应用的内嵌浏览器控件 WebView 去渲染 H5 页面，因此 h5 App 的渲染流水线和 Web 页面渲染相一致，能力也局限在 WebView 这一沙箱。

性能问题：
即首屏渲染优化问题，同时多出了一个 WebView 初始化的特有问题。

对于 WebView 初始化所带来的性能开销，不少公司针对自身的 APP 进行内核的定制化改造，诸如腾讯的 X5 内核以及阿里 UC 技术团队的 UCWebView 等。

针对资源加载所带来的白屏问题，业界又提出了离线包的优化方案。所谓离线包机制，大体思路就是将原有从线上加载 H5 应用，提前下发到本地，通过 FileIO 或是内存等方式直接进行页面渲染，达到接近原生的用户体验。

h5 容器的技术解决方案，h5 容器提供丰富的内置 JSAPI，增强版的 WebView 控件以及插件机制等能力，对原始版本的方案做了进一步功能高内聚和模块低耦合。
![img](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFyVYw2zWkOYOy4fia3zcJrpwoRKWqPOfWiaibY5Z9K0EBe3NxlscjSxn1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Cordova 是 Apache 一个开源的移动开发框架，这一框架的核心实现原理就是基于 Web 渲染技术。
![img](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUF91BGpSpFDwNWmVEKC54qyhmwF1tH1YWkJr3gEyce1ibUzdHZBzFNOvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Cordova 应用程序由几部分组成：

- Web App

应用程序代码的实现地方，采用的是 Web 技术，应用运行在原生控件 WebView 中

- HTML Rendering Engine

应用的渲染引擎，即 WebView，该渲染引擎是页面和 Native 实现双向通信的桥梁

- Cordova 插件

提供了 Cordova 和原生组件相互通信的接口并绑定到了标准的设备API上。这使你能够通过JavaScript 调用原生代码，这些核心插件包括的应用程序访问设备功能，比如：电源，相机，联系人等。

- Mobile OS

原生系统层，提供系统能力

## 小程序

小程序采用的技术手段仍脱离不了 Web 渲染方案，即采用 WebView 作为渲染引擎、JSBridge 的封装和离线包机制等，但是其最大创新之处在于将渲染层和逻辑层进行了分离，提供一个干净纯粹的 JavaScript 运行时，多 WebView 的架构使得用户体验进一步逼近原生体验。

![img](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFCPWRh7BI1UoLDibbyvFpg0XHlQ185BIWM17mAosXCFP7l71JjoRklCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

小程序的渲染层和逻辑层分别由两个线程管理，渲染层采用 WebView 进行页面渲染（iOS 使用 UIWebView/WKWebView，Android 使用 WebView），小程序的多页面也由多 WebView 接管。逻辑层从 WebView 分离，使用 JavaScript 引擎（iOS 使用 JavaScriptCore，Android 使用 V8）单独开启一个 Worker 线程去执行 JavaScript 代码。逻辑层和渲染层之间的通信经由 Native 层中转，网络 IO 也通过 Native 层进行转发。

![img](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFNhCJhCF8LWG3l2ZcFIKAEbSS1jib0yoUpibXBn4WG4hsBwhw7Waxkceg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

小程序采用多 WebView + 双线程模型的架构。由多 WebView 构成的视图层为页面性能赋予更加接近原生的用户体验，单个 WebView 承载更加轻量的页面渲染任务，JavaScript 脚本单独抽离在 Worker 线程限制了开发者直接操作页面的能力，进一步约束在微信小程序的规范下，这也是小程序无法直接操作 DOM 的缘由。

小程序的组件分为原生组件和非原生组件，对于原生组件而言，这就脱离的 Web 渲染方案的范畴，属于原生渲染方案的一部分，所以从这点上看，小程序也可以算得上是 Web 渲染和原生渲染的融合解决方案。综上来看，Web 渲染跨平台方案经历了三个阶段性的发展，从原始时期的 h5 + JSBridge + WebView，到 h5 容器的抽象提升，再到目前如火如荼的小程序。不难看出，Web 渲染方案的有如下特点：

- 开发效率高

采用 Web 技术，技术门槛相对较低，技术人员积累丰厚，社区资源丰富，对前端友好，一次开发，多端运行

- 动态化好

Web 技术的天然动态特性支持，无需发版

- 表现一致性佳

Web 页面除了个别元素和属性的差异、多屏适配外，其双端表现相对一致

- 性能较差

页面采用 WebView 渲染，页面加载耗时长，功能受限于沙箱，能力有限，难以承接复杂交互或是需要高性能的任务，整体用户体验差

## 原生渲染方案

原生渲染方案的基本思路是在 UI 层采用前端框架，然后通过 JavaScript 引擎解析 JS 代码，JS 代码通过 Bridge 层调用原生组件和能力，代表的框架是 React Native 和 Weex。

从原生渲染方案的实现思路不难看出，顶层采用类 Web 框架用于降低开发成本和统一技术栈，UI 的渲染通过 JSBridge 由原生控件直接接管，从而获得性能和体验的提升。

![img](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFAyQia5pgZia3ccKnA2uARkxPVib2fPZYG5V2dSjXycHR8Pqy29ZiaMLQsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- React 层

最顶层是 React 层，利用 React 框架进行 UI 的数据描述，开发者使用 Class Component 或 Functional Component 进行页面开发，框架内部将会把页面描述转化为 ReactElement 这一代表的虚拟 DOM 的数据结构，用于运行时的 Diff 对比和消息收发等

- [JS Bundle 中间产物]

React Native 通过 metro 打包功能直接将整个 RN 应用打包为一个 JSBundle，通过 Bridge 层在 RN 应用初始化时加载整个 JS 包进来

- Bridge 层

Bridge 是连接 React 和 Native 的中间层，React 层的 UI 需要通过 Bridge 层的 UIManager 接口实现原生控件的创建和更新，通过 NativeModules 接口实现原生能力的调用

- Native 层

在 Native 层中，Native Modules 实现了与上层交互的原生能力接口，Native UI 实现终端实际的控件展示，Yoga 跨平台布局引擎实现了基于 Flexbox 布局系统的 JS 和 Native 的镜像映射关系。

![i](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFg9GLC4eYJbia8rQia97icWoicPfqueWj6PcgS4YfVP8pen7royT1oWF3Lw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从线程模型角度，分析一下 RN 的运行机制：

- UI 线程

应用的主线程，用于处理原生控件的绘制

- JS 线程

React 构成的 JS 代码运行在此线程

- Shadow 线程

主要用于构建 JS 与原生控件的布局镜像数据

- Native Modules 线程

提供原生能力，这里采用的是多线程模型，iOS 端通过 GCD 实现，Android 端通过 AsyncTask 实现

![1](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFExibcZQcLIHC9rx7BrgLCgKibBldo72TtvOqC00iaVEIWMGMCSdC1wmrA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

RN 应用在 UI 线程进行初始化，初始化的内容包括加载 JSBundle、初始化 Native Modules 等原生能力模块、创建 JSC/Hermes JavaScript 引擎，执行 JS 代码。

创建的 JS 引擎独立在一个 JS 线程，解释执行 React 代码，并将生成的布局或逻辑信息序列化后经由 Bridge 发送给 Native。

React 代码中视图层的渲染通过 UIManager 调 createView/updateView 等方法，基于 Yoga 布局引擎创建对应的 shadowView；逻辑层中涉及原生能力调用的部分通过 RCTBridge 对象转发到相应的原生接口。Native 接收到 Bridge 层的消息，进行视图的更新或是功能处理。

原生渲染方案通过直接接管渲染层的方案，弥补了 Web 渲染方法在性能和体验上的不足，同时在顶层采用类 Web 的语法集，将开发技术边界延展至 Web 领域，同时可以很好的复用当前前端主流 UI 框架 React/Vue 的繁荣生态系统。

Native 层和 JS 层的通信所带来的性能瓶颈。一方面页面的更新和事件的响应经由 Native 触达 JS 层，再由 JS 层返回给 Native 层需要来回的时间成本，另一方面数据的交互需要频繁进行序列化和反序列化的转换。因此，在一些 UI 线程和 JS 线程存在持续频繁交互的场景（动画、滚动）等，RN 表现就不尽如人意。

## 自建渲染引擎渲染方案

通过自建渲染引擎方式，直接从底层渲染上实现 UI 的绘制，而 Flutter 就是跨平台、自渲染的代表

![1](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUFvODq6bSjSTGOz0Z3pS0F4tIo4ibCibjgVhIBhMwX3A7j1zRjiaP4icFHhg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Flutter 应用可以分为四层：

- Dart App 层

最顶层是 Dart App 层，以 Widget 为基本视图描述单元，构建起 UI 体系

- Flutter Framework 层

内置基础的 Flutter 组件，并根据不同平台的视觉风格体系，封装 Material 和 Cupertino 两套 UI 库供上层使用

- Flutter Engine 层

Flutter 框架的核心所在，包括 Dart 虚拟机、Skia 跨平台渲染引擎、文字排版、平台通道等，通过 Engine 层，建立起 Dart App 层和原生平台之间联系，从而实现二者的双向通信

- Embedder 层

平台嵌入层为 Flutter App 提供宿主环境、线程创建以及基于插件机制的原生能力扩展等 Flutter 在打包的时候，将 Dart 业务代码和 Flutter Engine 代码基于 iOS/Android 不同平台分别进行打包。Native 在启动时会通过调用 C++ 的各自实现（Java 通过 JNI，OC 天然支持）初始化 Flutter Engine 层提供的接口，创建 UI/GPU/IO 三个线程和实例化 Dart VM。Dart 业务代码在 Release 模式下采用 AOT 的方式进行编译，并运行在 Dart VM 中。

从线程模型机制，分析一下 Flutter App 的运行机制：

![1](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIoKOJfcQupkwexN4lHNRBUF3juSeKse6qqLbFnQeFO00LvqDFRSckORO5fiapYCE3YpVID3R7w3AFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- Platform 线程

Flutter 的主线程，由 Native 创建。负责平台 vsync 信号的回调注册，即当接收到从显示设备的 vsync 信号后，Platform 线程驱动 UI 线程的执行

- UI 线程

负责响应 vsync 信号，执行 Dart 层代码，驱动渲染管线的运行，将 Widget Tree 生成 Layer Tree 并提交给 GPU 线程做进一步处理

- GPU 线程

GPU 线程将 Layer Tree 转化为具体的绘制指令，并调用 skia 跨平台渲染引擎进行光栅化上屏

- IO 线程

主要负责请求图片资源并完成解码，然后将解码的图片生成纹理并传递给 GPU 线程

显示器在一帧 vblank 后，会向 GPU 发送 vsync 信号，Native 的 Plaform 线程接收到 vsync 信号后，执行绘制帧回调方法，即驱动 UI 线程进行 UI 绘制。

UI 线程中，Native 通过调用 C++ 的各自实现，将绘制指令通过 window 对象发送给 Dart 层，Dart 层会重构代表 UI 的数据树（Widget Tree，Element Tree 和 RenderObject Tree）并生成布局信息。根据布局信息生成一系列绘制指令的 Layer Tree，并通过 window 对象传递给 GPU 线程。

- 这里多提一句，Dart 层通过三棵树去描述 UI 的视图结构。

- - Widget Tree 是直接面向开发者的 UI 元素的配置信息，Widget 是 Immutable 的，如果 Widget 的状态发生更新，会发生重建。实际业务场景中，Widget 会频繁触发重建。
  - Element Tree 是 Widget Tree 和 RenderObject Tree 的桥梁，当Widget 发生变化后，会将其 Element 标记为 Dirty Element，在下一次 vsync 信号到来时进行渲染。当 Widget 挂载到 Widget Tree 时，会调用 widget.createElement 方法，创建其对应的 Element，Flutter 再讲这个 Element 挂载到 Element Tree 并持有有创建它的 Widget 的引用
  - RenderObject Tree 是真正执行组件布局渲染的工作，通过 RenderObjectToWidgetAdapter 这个 RenderObjectWidget 建立起 Widget 、Element 和 RenderObject 三者之间的联系

GPU 线程从 UI 线程获取 Layer Tree 构成的绘制指令，通过 Skia 这一跨平台渲染引擎进行光栅化，绘制成帧数据，将帧数据放在帧缓冲区，然后等待显示器上屏。综上来看，以 Flutter 为代表的的自建渲染引擎方案的优势在于：

- UI 控件是直接采用 Skia 这一跨平台渲染引擎进行绘制

顶层使用 Dart 的语法进行 UI 的配置信息描述，并通过 Diff 算法优化渲染流程，生成 Layer Tree 后，再调用 C++ 的代码将布局信息发送给 Flutter Engine，Flutter Engine 直接通过 Skia 将 UI 控件绘制上屏。这里与原生渲染方案最大的不同点在于，Native 应用仅作为宿主环境，UI 控件不需要转化为原生控件，直接采用渲染引擎进行绘制，从而保证了双端的一致性和良好的性能与体验。

- Dart 在 Release下采用 AOT 的 编译模式

Dart 代码在 Release 采用 AOT 的编译模式转化为二进制代码，从而在 Dart 运行时环境中执行效率更高，性能也更为卓越。对比 React Native 来说，由于打包的是 JSBundle，所以在运行时仍是基于 JavaScript 运行时进行解释执行 JS 代码，因而产生较大的性能瓶颈。

- UI 层与原生层的数据交换性能更高