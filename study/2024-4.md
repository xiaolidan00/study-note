2024 年 4 月份读书笔记

# tailwindcss

```txt
postcss postcss-import autoprefixer tailwindcss
```

```ts
//postcss.config.ts
export default {
  plugins: {
    'postcss-import': {},
    tailwindcss: {},
    autoprefixer: {}
  }
};
//tailwind.config.ts
/**@type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{html,ts,js,tsx,jsx}'],
  theme: {
    screens: {
      sm: '480px',
      md: '768px',
      lg: '976px',
      xl: '1440px'
    },
    // colors: {
    //     // Using modern `rgb`
    //     primary: 'rgb(var(--color-primary) / <alpha-value>)',
    //     secondary: 'rgb(var(--color-secondary) / <alpha-value>)',

    //     // Using modern `hsl`
    //     primary: 'hsl(var(--color-primary) / <alpha-value>)',
    //     secondary: 'hsl(var(--color-secondary) / <alpha-value>)',

    //     // Using legacy `rgba`
    //     primary: 'rgba(var(--color-primary), <alpha-value>)',
    //     secondary: 'rgba(var(--color-secondary), <alpha-value>)',
    //   },
    fontFamily: {
      sans: ['Graphik', 'sans-serif'],
      serif: ['Merriweather', 'serif']
    },
    extend: {
      spacing: {
        '128': '32rem',
        '144': '36rem'
      },
      borderRadius: {
        '4xl': '2rem'
      }
    }
  },
  plugins: []
};

//vite.config.ts
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';
export default defineConfig({
  css: {
    postcss: {
      plugins: [tailwindcss, autoprefixer]
    }
  }
});

//main.ts
import './assets/styles/tailwindcss.css';
```

```css
//tailwindcss.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --color-primary: 255 115 179;
    --color-secondary: 111 114 185;
    /* ... */
  }
}

@layer components {
  .btn-primary {
    @apply py-2 px-5 bg-violet-500 text-white font-semibold rounded-full shadow-md hover:bg-violet-700 focus:outline-none focus:ring focus:ring-violet-400 focus:ring-opacity-75;
  }
  .card {
    background-color: theme('colors.white');
    border-radius: theme('borderRadius.lg');
    padding: theme('spacing.6');
    box-shadow: theme('boxShadow.xl');
  }
}
```

```jsx
 <p className="read-the-docs card text-blue-500">
        Click on the Vite and React logos to learn more
      </p>
      <div className='font-bold underline hover:bg-sky-500'>AAA</div>
      <button className='btn-primary'>Click</button>
```

# Vue3 源码调试

```txt
ensureRenderer
createRenderer
baseCreateRenderer
initFeatureFlags//开发模式还是生产者模式
setDevtoolsHook//开发者模式开发工具hook
app.mount
 normalizeContainer
 mount
 createVNode _createVNode
 shapeFlag //组件标记 Suspense Teleport
 createBaseVNode
  normalizeChildren

  render
  patch

  processComponent
  mountComponent
  createComponentInstance  EffectScope normalizePropsOptions normalizeEmitsOptions
 //开发环境  devtool和HMR
  createDevRenderContext  registerHMR startMeasure

  isKeepAlive

  setupComponent  isStatefulComponent initProps initSlots setupStatefulComponent

  exposePropsOnRenderContext
  setCurrentInstance
  pauseTracking resetTracking
  handleSetupResult

  finishComponentSetup
  applyOptions
  registerLifecycleHook
  setupRenderEffect
  componentUpdateFn
  renderComponentRoot

  setupBlock
  cloneVNode
  mountChildren
  mountElement

  style setScopeId

  patchProp patchDOMProp

  ref改变
  hostParentNode getNextHostNode hostNextSibling
  patchBlockChildren
  patchElement
  invokeVNodeHook
  traverseStaticChildren
  updateHOCHostEl
```

## vue-template

https://template-explorer.vuejs.org/

# commitizen changelog

https://www.cnblogs.com/mengfangui/p/12634845.html

```json
//package.json
"scripts": {
    "commit": "git-cz",
    "genlog": "conventional-changelog -p angular -i CHANGELOG.md -s",
     "genlogorg": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0"

  },
 "devDependencies": {
 "commitizen": "^4.3.0",
    "conventional-changelog-cli": "^4.1.0",
    "cz-conventional-changelog": "^3.3.0",
},
"config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  }

  //npm run commit
  // npm run genlog
```

# React 源码调试

```txt
ReactDOM.createRoot(document.getElementById('root')!).render()

createContainer

createFiberRoot->new FiberRootNode()->createLaneMap

createHostRootFiber

createFiber->new FiberNode()

initializeUpdateQueue

markContainerAsRoot

listenToAllSupportedEvents->listenToNativeEvent->addTrappedEventListener->createEventListenerWrapperWithPriority->getEventPriority->addEventCaptureListenerWithPassiveFlag|addEventCaptureListener|addEventBubbleListenerWithPassiveFlag|addEventBubbleListener->target.addEventListener

new ReactDOMRoot()->createRoot->jsxWithValidation->isValidElementType->jsxDEV->hasValidKey->hasValidRef->ReactElement->   validateFragmentProps->validatePropTypes->validateChildKeys

ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render->isValidContainer->findHostInstanceWithNoPortals->findCurrentHostFiberWithNoPortals->findCurrentFiberUsingSlowPath->getNearestMountedFiber->findCurrentHostFiberWithNoPortalsImpl

updateContainer->onScheduleRoot->injectedHook.onScheduleFiberRoot->injectIntoGlobalHook->requestEventTime->requestUpdateLane->  requestCurrentTransition->getCurrentUpdatePriority->getCurrentEventPriority->markRenderScheduled->getContextForSubtree

createUpdate->enqueueUpdate->isUnsafeClassRenderPhaseUpdate->enqueueConcurrentClassUpdate->pushConcurrentUpdateQueue->markUpdateLaneFromFiberToRoot->mergeLanes

scheduleUpdateOnFiber->checkForNestedUpdates->markRootUpdated->laneToIndex->pickArbitraryLaneIndex->addFiberToLanesMap->ensureRootIsScheduled-> markStarvedLanesAsExpired->lanesToEventPriority->scheduleCallback->requestHostCallback->flushWork->workLoop->advanceTimers

performConcurrentWorkOnRoot->flushPassiveEffects->getNextLanes

renderRootSync->pushDispatcher->movePendingFibersToMemoized->prepareFreshStack

createWorkInProgress->finishQueueingConcurrentUpdates

 ReactStrictModeWarnings.discardPendingWarnings

markRenderStarted->performUnitOfWork->setCurrentFiber

assignFiberPropertiesInDEV

beginWork->checkScheduledUpdateOrContext

updateHostRoot->pushHostRootContext->pushTopLevelContextObject->pushHostContainer

cloneUpdateQueue

processUpdateQueue

getStateFromUpdate

markSkippedUpdateLanes

reconcileChildren

reconcileSingleElement

createFiberFromElement->createFiberFromTypeAndProps

coerceRef

mountIndeterminateComponent->prepareToReadContext->markComponentRenderStarted

renderWithHooks

entangleTransitions

BrowserRouter->createBrowserHistory->getUrlBasedHistory->React.useLayoutEffect(() => history.listen(setState), [history, setState]);

mountWorkInProgressHook->mountRef

HooksDispatcherOnMountInDEV

mountState

renderWithHooks

createElementWithValidation

createElement->ReactElement
```

# monorepo

package.json

```json
{
  "name": "my-monorepo",
  "version": "1.0.0",
  "description": "",
  "main": "src/index.js",
  "type": "module",
  "scripts": {
    "dev": "node ./src/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "engines": {
    "node": ">=10",
    "pnpm": ">=3"
  },
  "dependencies": {
    "my-utils": "workspace:*"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "typescript": "^5.4.4"
  }
}
```

pnpm-workspace.yaml

```yaml
packages:
  #包含
  - 'packages/**'
  - 'components/**'
  #排除
  - '!**/test/**'
```

packages/my-utils/src/index.js

```js
import { hello } from 'my-utils';
hello('world');
//pnpm i //自动将packages安装到workspance
```

packages/my-utils//package.json

```json
{
  "name": "my-utils",
  "version": "1.0.0",
  "description": "",
  "type": "module",
  "main": "./src/index.js",
  "files": ["src"],
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "module": "./src/index.js",
  "exports": {
    ".": {
      "import": "./src/index.js"
    }
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

# BFF

https://zhuanlan.zhihu.com/p/634498512
BFF 是一种 Web 架构，全名为 Backends For Frontends，即为服务于前端的后端。
BFF 一般指的是在前端与后端之间加增加一个中间层。

单一的 BFF 主要对接服务端，根据展示服务的需求组装数据提供给每个端或者每种业务进行展示。

多端 BFF 是指每种业务或者每种客户端采用自己独立的 BFF 层，这样每种客户端的服务更加灵活，不同的 BFF 端对于展示服务解耦性更高。

**优势**

1. 服务端对数据展示服务进行解耦，展示服务由独立的 BFF 端提供，服务端可以聚焦于业务处理。
2. 多端展示或者多业务展示时，对与数据获取有更好的灵活性，避免数据冗余造成消耗服务端资源。
3. 对于复杂的前端展示，将数据获取和组装的负责逻辑在 BFF 端执行，降低前端处理的复杂度，提高前端页面响应效率。
4. 部分展示业务，可以抽象出来利用 BFF 实现，对于服务端实现接口复用。
5. 降低多端业务的耦合性，避免不同端业务开发互相影响。
6. 其他优势，包括数据缓存，接口安全校验等。

# Faas

https://www.ibm.com/cn-zh/topics/faas
FaaS（即功能即服务）是一种https://www.ibm.com/cn-zh/topics/cloud-computing服务，允许客户执行代码来响应事件，而无需管理通常与构建和启动

在互联网上托管软件应用程序通常需要配置和管理虚拟服务器或物理服务器，并管理操作系统和网络服务器托管流程。通过 FaaS，物理硬件、虚拟机操作系统和 Web 服务器软件管理都由云服务提供商自动处理。这样，开发人员就可以只关注应用程序代码中的各个功能。

# React 推出 Compiler

https://mp.weixin.qq.com/s/iNkxFOa18k9wG6RbGYvQMQ

- useMemo、useCallback、memo → React Compiler 将自动处理和优化组件的重渲染和回调函数的生成，使这些函数将成为过去。
- forwardRef → 引用(ref)将被视为一个普通的 props，你可以像处理其他 props 一样处理它，无需额外的 forwardRef 函数。
- React.lazy → 用于代码分割的 React.lazy 也将被新的 RSC（React Server Component）和 promise-as-child 替代，这将对异步组件加载提供更好的支持。
- useContext → 你只需使用 use(Context)，就可以直接获取到 Context 的值，大大简化了 Context 的使用。
- throw promise → 你可以直接使用 use(promise)，让异步操作变得更加简单，无需再显式地去抛出和捕获 Promise。
- `<Context.Provider>` → 你只需使用 `<Context>`，而不再需要 `<Context.Provider>`，这将使 Context 的提供者更容易使用和管理。

# Redis

https://blog.csdn.net/weixin_44893902/article/details/123087435

# PM2

https://pm2.fenxianglu.cn/docs/general/restart-strategies
https://juejin.cn/post/6844904014627389448

# nginx

https://blog.csdn.net/weixin_44251179/article/details/129700793
https://zhuanlan.zhihu.com/p/456376971

```yaml
 server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;


		location /api/{
			proxy_pass http://localhost:4000/;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		}

        location / {
            root   html;
            index  index.html index.htm;
        }
   }

```

# 禁止调试

https://juejin.cn/post/6976250246376456206

# 禁止 iframe 嵌套

https://cloud.tencent.com/developer/article/1559358

https://developer.mozilla.org/zh-CN/docs/web/http/headers/x-frame-options

framekiller

```js
<style> html{display:none;} </style>
<script>
if(self == top) {
  document.documentElement.style.display = 'block';
} else {
  top.location = self.location;
}
</script>
```

```yaml
# 不允许被嵌入，包括<frame>, <iframe>, <object>, <embed> 和 <applet>
Content-Security-Policy: frame-ancestors 'none'
# 只允许被同源的页面嵌入
Content-Security-Policy: frame-ancestors 'self'
# 只允许被白名单内的页面嵌入
Content-Security-Policy: frame-ancestors www.example.com

# 不允许被嵌入，包括<frame>, <iframe>, <embed> 和 <object>
X-Frame-Options: deny
# 只允许被同源的页面嵌入
X-Frame-Options: sameorigin
# （已废弃）只允许被白名单内的页面嵌入
X-Frame-Options: allow-from www.example.com
```

响应请求头设置不可 iframe 嵌套

```js
ctx.respond.headers['X-Frame-Options'] = 'SAMEORIGIN';
```

# 触屏左右滑动 onDomTouch

```js
export function onDomTouch(dom, cb) {
  let startx, starty;
  let isTouch = 'ontouchend' in document;
  //获得角度
  function getAngle(angx, angy) {
    return (Math.atan2(angy, angx) * 180) / Math.PI;
  }

  //根据起点终点返回方向 1向上滑动 2向下滑动 3向左滑动 4向右滑动 0点击事件
  function getDirection(startx, starty, endx, endy) {
    let angx = endx - startx;
    let angy = endy - starty;

    //如果滑动距离太短
    if (Math.abs(angx) < 2 && Math.abs(angy) < 2) {
      return 'click';
    }

    let angle = getAngle(angx, angy);
    if (angle >= -135 && angle <= -45) {
      return 'up';
    } else if (angle > 45 && angle < 135) {
      return 'down';
    } else if ((angle >= 135 && angle <= 180) || (angle >= -180 && angle < -135)) {
      return 'left';
    } else if (angle >= -45 && angle <= 45) {
      return 'right';
    }
    return 'click';
  }

  const startFun = (e) => {
    if (isTouch) {
      startx = e.touches[0].pageX;
      starty = e.touches[0].pageY;
    } else {
      startx = e.pageX;
      starty = e.pageY;
    }
  };

  const endFun = (e) => {
    let endx, endy;
    if (isTouch) {
      endx = e.changedTouches[0].pageX;
      endy = e.changedTouches[0].pageY;
    } else {
      endx = e.pageX;
      endy = e.pageY;
    }
    let direction = getDirection(startx, starty, endx, endy);
    console.log('滑动', direction);
    cb && cb(direction);
  };
  if (isTouch) {
    //手指接触屏幕
    dom.addEventListener('touchstart', startFun, false);
    //手指离开屏幕
    dom.addEventListener('touchend', endFun, false);
  } else {
    dom.addEventListener('pointerdown', startFun, false);
    dom.addEventListener('pointerup', endFun, false);
  }

  return {
    startFun,
    endFun,
    isTouch
  };
}
```
