# 前端异常处理一站式详解

<https://juejin.cn/post/7352661916387475494>

# 深入理解 TypeScript 高级用法

<https://zhuanlan.zhihu.com/p/136254808>

# 领域驱动设计

<https://developer.aliyun.com/article/1307643>

# lighthouse使用

<https://www.cnblogs.com/wenxuehai/p/14236426.html>

# provide/inject注入更新

注入数据更新时

1. template没有使用，那么onUpdated不会触发，只有template使用，onUpdated才会触发更新模板
2. setup内使用会自动更新

# TypeScript装饰器

[一文搞懂 TypeScript 装饰器](http://mp.weixin.qq.com/s?__biz=MzU2NjU3Nzg2Mg==&mid=2247521321&idx=1&sn=aa2ea8b5f9dd1719bd767f4d135ccc0e&chksm=fca88b80cbdf0296b7c8251575d898f5a1c8b0807e05e3670e81d399fc96eaeb6a11310829cf&mpshare=1&scene=1&srcid=0515rT9dgUsaBBbz6BWFZgYu&sharer_shareinfo=1e9272862d5d6a6b8bd4adebab256923&sharer_shareinfo_first=1e9272862d5d6a6b8bd4adebab256923#rd)

[阮一峰](https://typescript.p6p.net/typescript-tutorial/decorator.html#%E7%AE%80%E4%BB%8B)

装饰器的分类从写法上来区分，可分为：

- 普通装饰器（不可带参数）

```ts
/**  
 * 类装饰器(普通装饰器写法)  
 */  
export function Route(target: object) {  
  //TODO  
  ...  
}  
    
//=========================================================  
    
/**  
 * 使用 Route 装饰器:  
 */  
@Route()  
struct DetailPage {  
  build() {  
    ...  
  }  
}
```

- 装饰器工厂（可以带参数）

```ts
/**  
 * 类装饰器(装饰器工厂实现)  
 */  
export function Route(routePath: string): ClassDecorator {  
  return (target: object) => {  
    //TODO  
    ...  
  }  
}  
  
//=========================================================  
   
/**  
 * 使用 Route 装饰器:  
 */  
@Route({ routePath: '/jump/entry/detail'})  
struct DetailPage {  
  build() {  
    ...  
  }  
}
```

从类别上来区分，TypeScript中装饰器主要分为以下五类：

- 类装饰器 ClassDecorator

```ts
type ClassDecorator = <TFunction extends Function>(  
  target: TFunction  
) => TFunction | void;

function CustomClassDecorator(info: string): ClassDecorator {  
  return (target: Function) => {  
    console.log(target) // [Function user]  
    console.log(info) // 你好  
  }  
}  
  
@CustomClassDecorator('你好')  
class User {  
  public name!: string  
  
  constructor() {  
    this.name = '马东锡'  
  }  
}
```

- 属性装饰器 PropertyDecorator

```ts
type PropertyDecorator = (  
  target: Object,  
  propertyName: string | symbol  
) => void;

function CustomPropertyDecorator(userName: string): PropertyDecorator {  
  return (target: Object,  
          propertyName: string | symbol) => {  
  
    console.log(target); // {}  
    console.log(propertyName); // userName  
  
    targetClassPrototype[propertyName] = userName  
  }  
}  
  
class User {  
  @CustomPropertyDecorator('马东锡')  
  public userName!: string  
  
  constructor() {  
  
  }  
}  
  
let user = new User()  
console.log(user.userName) // 马东锡
```

- 方法装饰器 MethodDecorator

```ts
type MethodDecorator = <T>(  
  target: Object,  
  methodName: string | symbol,  
  propertyDescriptor: TypedPropertyDescriptor<T>  
) => TypedPropertyDescriptor<T> | void;

function CustomMethodDecorator(info: string): MethodDecorator {  
  return (target: Object,  
          methodName: any,  
          propertyDescriptor: PropertyDescriptor) => {  
    console.log(target) // { sayHello: [Function (anonymous)] }  
    console.log(methodName) //sayHello  
  
    let originMethod = propertyDescriptor.value  
  
    propertyDescriptor.value = function (...args: any) {  
      console.log("before")  
      console.log("我" + info + "来了") //我马东锡来了  
      originMethod.call(this, args)  
      console.log("after")  
    }  
  }  
}  
  
class User {  
  @CustomMethodDecorator('马东锡')  
  sayHello() {  
    console.log('执行sayHello()方法)')  
  }  
}
```

- 参数装饰器 ParameterDecorator

```ts

type ParameterDecorator = (
  target: Object,
  methodName: string | symbol,
  parameterIndex: number
) => void;

function CustomParameterDecorator(tag: string): ParameterDecorator {  
  return (target: any,  
          methodName: string | symbol,  
          parameterIndex: number) => {  
  
    console.log(tag); // 装饰实例方法的参数  
    console.log(target); // { sayHello: [Function (anonymous)] }  
    console.log(methodName.toString()); // sayHello  
    console.log(parameterIndex.toString()); // 0  
  
  }  
}  
  
class User {  
  constructor() {  
  
  }  
  
  sayHello(@CustomParameterDecorator("装饰实例方法的参数") name: String) {  
    console.log("你好，" + name);  
  }  
}
 
```

- 访问符装饰器 AccessorDecorator

## 浏览器缓存

[带你了解透彻浏览器缓存！](https://juejin.cn/post/7221750009141526565)

## 跨域问题多种解决方案的精华总结

[开发阶段！跨域问题多种解决方案的精华总结](https://juejin.cn/post/7367676494977302538)

## chrome调试火焰图

<https://blog.csdn.net/qianyu6200430/article/details/111026894>

## react性能优化

<http://mp.weixin.qq.com/s?__biz=MzU2NjU3Nzg2Mg==&mid=2247520729&idx=1&sn=1f6e8b97bb9b36e0edbbb47c4f8d67bb&chksm=fca88e70cbdf07665d2722cd8006cf0c10e51695a8f8a19f362d8609fe9ca1bedaeec112599e&mpshare=1&scene=1&srcid=0514OZ8bqyxOp2FPXBTuBSsy&sharer_shareinfo=28af858273fdd8fd16ab2ba30486d30b&sharer_shareinfo_first=28af858273fdd8fd16ab2ba30486d30b#rd>

## npm包bug

<https://juejin.cn/post/7356534347509497919>
patch-package

pnpm patch

## 编译代码反编译

```bash
npm install --global reverse-sourcemap

# 单个sourceMap文件反编译
reverse-sourcemap -o aaa -v app.9fbea7c7.js.map
# 将 app.9fbea7c7.js.map 反编译到 aaa 目录下

# 批量sourceMap反编译
reverse-sourcemap -o origin -v ./static/js
# 将 ./static/js目录下所有的 .js.map 类型的文件（递归）反编译到 origin 目录下面
```

# 前端性能检测工具web-vitals

```
import { ReportHandler } from 'web-vitals'

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry)
      getFID(onPerfEntry)
      getFCP(onPerfEntry)
      getLCP(onPerfEntry)
      getTTFB(onPerfEntry)
    })
  }
}

export default reportWebVitals
```

# redux

<https://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts>

- **state**：驱动应用的真实数据源头
- **view**：基于当前状态的视图声明性描述
- **actions**：根据用户输入在应用程序中发生的事件，并触发状态更新

接下来简要介绍  **"单向数据流（one-way data flow）"** :

- 用 state 来描述应用程序在特定时间点的状况
- 基于 state 来渲染出 View
- 当发生某些事情时（例如用户单击按钮），state 会根据发生的事情进行更新，生成新的 state
- 基于新的 state 重新渲染 View

- 初始启动：

  - 使用最顶层的 root reducer 函数创建 Redux store
  - store 调用一次 root reducer，并将返回值保存为它的初始 `state`
  - 当视图 首次渲染时，视图组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便他们可以知道 state 是否已更改。

- 更新环节：

  - 应用程序中发生了某些事情，例如用户单击按钮
  - dispatch 一个 action 到 Redux store，例如 `dispatch({type: 'counter/increment'})`
  - store 用之前的 `state` 和当前的 `action` 再次运行 reducer 函数，并将返回值保存为新的 `state`
  - store 通知所有订阅过的视图，通知它们 store 发生更新
  - 每个订阅过 store 数据的视图 组件都会检查它们需要的 state 部分是否被更新。
  - 发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页

![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5a3508ddca4b2e933d46fcc40a0a56~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1280\&h=866\&s=25103\&e=png\&b=ffffff)

**总结**

- **Redux 是一个管理全局应用状态的库**

  - Redux 通常与 React-Redux 库一起使用，把 Redux 和 React 集成在一起
  - Redux Toolkit 是编写 Redux 逻辑的推荐方式

- **Redux 使用 "单向数据流"**

  - State 描述了应用程序在某个时间点的状态，视图基于该 state 渲染

  - 当应用程序中发生某些事情时：

    - 视图 dispatch 一个 action
    - store 调用 reducer，随后根据发生的事情来更新 state
    - store 将 state 发生了变化的情况通知 UI

  - 视图基于新 state 重新渲染

- **Redux 有这几种类型的代码**

  - *Action* 是有 `type` 字段的纯对象，描述发生了什么
  - *Reducer* 是纯函数，基于先前的 state 和 action 来计算新的 state
  - 每当 dispatch 一个 action 后，*store* 就会调用 root reducer

```ts
//chartReducer
import { createSlice, type PayloadAction } from '@reduxjs/toolkit';
import { type RootState } from './store';

export interface EchartsOption {
  [n: string | number]: string | number | boolean | EchartsOption;
}
export interface ChartState {
  value: number;
  options: string[];
  series: string[];
  config: EchartsOption;
  seriesConfig: EchartsOption[];
}

const initialState: ChartState = {
  value: 0,
  options: [],
  series: [],
  config: {},
  seriesConfig: []
};
export const chartSlice = createSlice({
  name: 'chart',
  initialState,
  reducers: {
    addSeries: (state, action: PayloadAction<string>) => {
      state.series.push(action.payload);
    },
    addOptions: (state, action: PayloadAction<string>) => {
      state.options.push(action.payload);
    },
    delSeries: (state, action: PayloadAction<number>) => {
      state.series.splice(action.payload, 1);
    },
    delOptions: (state, action: PayloadAction<number>) => {
      state.options.splice(action.payload, 1);
    },
    setConfig: (state, action: PayloadAction<EchartsOption>) => {
      state.config = action.payload;
    },
    setSeriesConfig: (state, action: PayloadAction<EchartsOption[]>) => {
      state.seriesConfig = action.payload;
    }
  }
});

export const actions = chartSlice.actions;

export const getters = {
  chartConfig: (state: RootState) => state.chart.config,
  chartOptions: (state: RootState) => state.chart.options,
  chartSeries: (state: RootState) => state.chart.series,
  chartSeriesConfig: (state: RootState) => state.chart.seriesConfig
};

export default chartSlice.reducer;

//hook
import { useDispatch, useSelector } from 'react-redux';
import type { AppDispatch, RootState } from './store';

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>();
export const useAppSelector = useSelector.withTypes<RootState>();

//store
import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';
import chartReducer from './chartReducer';

const store = configureStore({
  reducer: {
    chart: chartReducer
  }
});
export default store;
// 从 store 本身推断出 `RootState` 和 `AppDispatch` 类型
export type RootState = ReturnType<typeof store.getState>;
// 推断出类型: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch;

export type AppThunk<ReturnType = void> = ThunkAction<ReturnType, RootState, unknown, Action<string>>;


//main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.scss';
import { Provider } from 'react-redux';
import { type ThemeConfig, theme, ConfigProvider } from 'antd';
import store from './store/store.ts';
const config: ThemeConfig = {
  algorithm: theme.darkAlgorithm
};
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Provider store={store}>
      <ConfigProvider theme={config}>
        <App />
      </ConfigProvider>
    </Provider>
  </React.StrictMode>
);

```

# vitest测试库

<https://vitest.dev/>

# vscode调试手册

<https://blog.csdn.net/shentian885/article/details/123896536>

# 监听css 动画事件

<https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animationend_event>

- animationend结束
- animationstart开始
- animationiteration循环

# 动画库

这里是使用 [GSAP 库](https://gsap.com/)执行动画的一个示例，你也可以使用任何你想要的库，比如 [Anime.js](https://animejs.com/) 或者 [Motion One](https://motion.dev/)：

# 张鑫旭大佬博客

<https://www.zhangxinxu.com/>

# css滚动对齐scroll-snap-align

<https://segmentfault.com/a/1190000038459089>

# scroll-width

隐藏滚动条：scroll-width:none

# 顺滑滚动

scroll-behavior:smooth

# css滚动条冲突overscroll-behavior

`overscroll-behavior` 属性可以使用下面列表中的一或两个关键字指定。

使用两个关键字来指定 `overscroll-behavior` 分别在 `x` 和 `y` 轴的值。只用一个值的话，x 和 y 轴都被指定为该值。

[值](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overscroll-behavior#%E5%80%BC)

- [`auto`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overscroll-behavior#auto)

    默认效果

- [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overscroll-behavior#contain)

    设置这个值后，默认的滚动边界行为不变（“触底”效果或者刷新），但是临近的滚动区域不会被滚动链影响到，比如对话框后方的页面不会滚动。

- [`none`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overscroll-behavior#none)

    临近滚动区域不受到滚动链影响，而且默认的滚动到边界的表现也被阻止。

```js
//el-scrollbar>滚动固定行高
export function onScrollTable(bodyRef, rowheight, time) {
  if (!bodyRef) return;
  let wrap = bodyRef.$refs.wrap;

  let timer = setInterval(() => {
    if (Math.ceil(wrap.scrollTop) < wrap.scrollHeight - wrap.offsetHeight) {
      wrap.style.scrollBehavior = `smooth`;
      wrap.scrollTo(0, Math.floor(wrap.scrollTop / rowheight) * rowheight + rowheight);
    } else {
      wrap.style.scrollBehavior = `auto`;
      setTimeout(() => {
        wrap.scrollTo(0, 0);
      });
    }
    bodyRef.handleScroll();
    bodyRef.update();
  }, time);
  return timer;
}

```

## websocket

<https://juejin.cn/post/7346919387353219106>
