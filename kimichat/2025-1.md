# href 和 src 的区别？

4. 在网页中，`href`和`src`是两种常见的属性，它们在功能和使用场景上有着明显区别：
   
   ### 1. 基本概念
   
   - **href（Hyperlink Reference）**
     - **定义**：用于指定超链接目标的地址，即告诉浏览器链接指向的资源位置。
     - **使用场景**：主要用在`<a>`（超链接）、`<link>`（引入外部资源如样式表）、`<area>`（图像映射区域）等元素上。
     - **作用**：当用户点击带有`href`属性的元素（如超链接）时，浏览器会根据`href`指定的地址加载新的页面或资源。例如`<a href="https://www.example.com">访问示例网站</a>`，点击后会跳转到`https://www.example.com`这个网址。
   - **src（Source）**
     - **定义**：用于指定嵌入资源的路径，即告诉浏览器要嵌入到当前页面中的资源在哪里。
     - **使用场景**：常用于`<img>`（图片）、`<script>`（脚本）、`<iframe>`（内嵌框架）、`<embed>`（嵌入外部内容）、`<object>`（插入对象）等元素。
     - **作用**：当页面加载时，浏览器会自动根据`src`属性指定的路径加载相应的资源，并将其嵌入到当前页面的相应位置。例如`<img src="image.jpg">`，页面加载时会加载`image.jpg`这张图片并显示在页面上。
   
   ### 2. 资源加载时机
   
   - **href**
     - 一般是在用户触发（如点击超链接）时，才去加载`href`指定的资源。例如对于超链接，只有当用户点击链接时，浏览器才会去请求`href`对应的网址内容。
   - **src**
     - 是在页面加载过程中自动加载`src`指定的资源。比如页面中有多个图片元素，每个图片元素的`src`指向不同的图片文件，浏览器在解析页面时会依次加载这些图片文件。
   
   ### 3. 对页面结构的影响
   
   - **href**
     - 更多是用于页面之间的跳转或者引入外部资源来辅助当前页面（如通过`<link>`引入样式表来美化页面），不会改变当前页面的结构，只是在用户操作时进行页面跳转或资源引入。
   - **src**
     - 会直接影响当前页面的结构和内容。例如插入一个`<img>`元素，通过`src`加载图片后，图片会成为页面内容的一部分，可能会改变页面的布局等。如果页面中有多个`<script>`元素，每个`<script>`的`src`加载不同的脚本文件，这些脚本文件中的代码会执行，可能会对页面的结构、样式、行为等产生影响。
   
   ### 4. 错误处理
   
   - **href**
     - 如果`href`指向的资源不存在或无法访问，通常不会对当前页面产生明显影响，只是超链接无法正常跳转。例如一个超链接指向了一个不存在的网页，点击后浏览器可能会显示404错误页面，但原页面不受影响。
   - **src**
     - 若`src`指定的资源加载失败，可能会导致页面显示不完整或功能异常。比如图片加载失败，图片位置会显示一个默认的图片占位符；脚本加载失败，可能会导致依赖该脚本的功能无法正常使用。

# href 加载会阻塞 html 的解析或渲染吗？

`href`加载是否阻塞 HTML 的解析或渲染，取决于具体的使用场景和元素类型，以下是详细分析：

### `<a>`元素中的`href`

- **不会阻塞**
  - 当`<a>`元素用于创建超链接时，`href`属性只是指定了链接的目标地址。在页面加载和解析过程中，浏览器不会主动去加载`href`指向的资源，除非用户点击该超链接。
  - 例如，页面中有`<a href="https://www.example.com">点击访问</a>`，在页面加载时，浏览器不会去请求`https://www.example.com`这个网址的内容，只是将这个链接信息存储起来。只有当用户点击这个链接时，浏览器才会发起对`https://www.example.com`的请求，此时页面的初始加载和解析过程已经完成，所以`<a>`元素中的`href`不会阻塞 HTML 的解析或渲染。

### `<link>`元素中的`href`（引入样式表）

- **会阻塞渲染（通常情况下）**
  - 当使用`<link>`元素引入外部 CSS 样式表时，`href`属性指定样式表的路径。浏览器在解析到`<link>`元素时，会暂停 HTML 文档的解析，优先加载并解析样式表文件。
  - 这是因为 CSS 样式表对页面的布局和外观至关重要，浏览器需要先获取样式信息，才能正确地渲染页面内容。例如，在`<head>`部分有`<link rel="stylesheet" href="style.css">`，浏览器在解析到这个`<link>`元素后，会立即去请求`style.css`文件，等待样式表加载并解析完成后，才会继续解析后续的 HTML 内容并进行渲染。
  - 不过，也有一些特殊情况，比如使用了`rel="preload"`或`rel="prefetch"`等属性时，加载行为和对渲染的影响会有所不同。`preload`用于预加载资源，浏览器会根据指定的资源类型（如`as="style"`）来决定是否阻塞渲染；`prefetch`则是用于预取资源，通常不会阻塞当前页面的渲染，而是作为潜在的后续导航资源进行提前获取。

### `<area>`元素中的`href`

- **不会阻塞**
  - `<area>`元素通常用于图像映射，定义图像上的可点击区域。其`href`属性指定点击该区域时的目标地址。
  - 和`<a>`元素类似，在页面加载和解析过程中，浏览器不会主动加载`<area>`元素`href`指向的资源，只有当用户点击对应的图像区域时，才会发起请求。所以`<area>`元素中的`href`不会阻塞 HTML 的解析或渲染。

# Vue 2 和 Vue 3 的 nextTick 实现原理

#### Vue 2 的 `nextTick` 实现原理

1. **功能**：

   - `nextTick` 的主要功能是在数据变化后等待 DOM 更新完成后再执行一些操作。

2. **实现机制**：

   - **异步更新队列**：Vue 2 使用异步更新队列来处理数据变化。当数据变化时，Vue 会将更新操作放入一个队列中，而不是立即更新 DOM。
   - **微任务和宏任务**：`nextTick` 利用了 JavaScript 的事件循环机制，将回调函数推迟到下一个事件循环中执行。具体实现方式如下：
     - **Promise**：如果环境支持 Promise，`nextTick` 会使用 Promise 来创建一个微任务。
     - **MutationObserver**：如果环境不支持 Promise 但支持 MutationObserver，`nextTick` 会使用 MutationObserver 来创建一个微任务。
     - **setTimeout**：如果环境既不支持 Promise 也不支持 MutationObserver，`nextTick` 会回退到使用 setTimeout 来创建一个宏任务。

3. **源码实现**：

   - `nextTick` 方法将回调函数放入一个回调队列 `callbacks` 中，并通过 `timerFunc` 触发异步任务来执行这些回调。
   - 如果没有提供回调函数且环境支持 Promise，`nextTick` 会返回一个 Promise，以便可以通过 `then` 方法链式调用回调。

   JavaScript复制

   ```javascript
   export function nextTick (cb?: Function, ctx?: Object) {
     let _resolve
     callbacks.push(() => {
       if (cb) {
         try {
           cb.call(ctx)
         } catch (e) {
           handleError(e, ctx, 'nextTick')
         }
       } else if (_resolve) {
         _resolve(ctx)
       }
     })
     if (!pending) {
       pending = true
       timerFunc()
     }
     if (!cb && typeof Promise !== 'undefined') {
       return new Promise(resolve => {
         _resolve = resolve
       })
     }
   }
   ```

#### Vue 3 的 `nextTick` 实现原理

1. **功能**：

   - `nextTick` 的功能与 Vue 2 类似，用于确保在 DOM 更新完成后执行某些操作。

2. **实现机制**：

   - **异步更新队列**：Vue 3 也使用异步更新队列来处理数据变化。当数据变化时，Vue 会将更新操作放入一个队列中，而不是立即更新 DOM。
   - **微任务**：`nextTick` 通过将回调函数推入微任务队列中，确保在当前事件循环的所有同步任务和 DOM 更新任务完成后执行该回调。

3. **源码实现**：

   - `nextTick` 方法依赖于一个全局的 `Promise` 来推迟回调的执行。具体实现如下：
     - **currentFlushPromise**：如果有一个正在处理的 DOM 更新队列的 `Promise`，则直接使用这个 `Promise`，等待它完成。
     - **resolvedPromise**：如果没有 `currentFlushPromise`，则使用一个立即解析的 `Promise`，将任务推入微任务队列中。
     - **返回 Promise**：`nextTick` 总是返回一个 `Promise`，可以通过 `then` 方法链式调用回调，确保回调函数在 Vue 异步 DOM 更新任务完成后执行。

   JavaScript复制

   ```javascript
   const resolvedPromise = Promise.resolve();
   let currentFlushPromise = null;
   
   export function nextTick<T = void>(this: T, fn?: () => T): Promise<T> {
     const p = currentFlushPromise || resolvedPromise;
     return fn ? p.then(this ? fn.bind(this) : fn) : p;
   }
   ```

#### Vue 2 和 Vue 3 的 `nextTick` 区别

1. **实现方式**：
   - **Vue 2**：维护一个 `callbacks` 数组，每次更新过程中只插入一个微任务，执行放在 `callbacks` 数组中的回调。
   - **Vue 3**：`nextTick` 和 `Promise` 基本没有区别，只是将创建一个已解析状态的 `Promise`，将传入的函数放入回调中。
2. **性能优化**：
   - **Vue 3**：进行了优化，提高了性能和稳定性。
3. **使用方式**：
   - **Vue 2**：通过 `this.$nextTick` 调用。
   - **Vue 3**：通过 `nextTick` 调用，用法和原理基本类似。

### 总结

- **Vue 2** 的 `nextTick` 通过维护一个回调队列和使用微任务或宏任务来确保在 DOM 更新完成后执行回调。
- **Vue 3** 的 `nextTick` 通过依赖全局 `Promise` 和微任务机制来确保在 DOM 更新完成后执行回调，实现更为简洁和高效。

希望这些信息对你有所帮助！

# npm，yarn，pnpm三者的区别

`npm`、`yarn` 和 `pnpm` 都是 JavaScript 项目的包管理工具，用于安装、管理和更新项目依赖。它们各有特点和优势，以下是它们之间的主要区别：

### 1. **安装速度**

- **npm**
  - 早期版本的 `npm` 安装速度较慢，因为它会递归安装所有依赖，并且每个依赖都会安装在 `node_modules` 目录下。
  - 新版本的 `npm`（特别是 `npm@7` 及以上）进行了优化，安装速度有所提升，但仍然不如 `yarn` 和 `pnpm`。
- **yarn**
  - `yarn` 通过并行安装和缓存机制显著提高了安装速度。它会缓存已安装的包，避免重复下载，同时并行处理多个依赖的安装。
  - `yarn` 还使用了锁文件（`yarn.lock`），确保所有开发者在项目中使用相同的依赖版本。
- **pnpm**
  - `pnpm` 通过硬链接（hard links）和符号链接（symlinks）来优化安装速度。它将所有依赖安装在一个全局存储中，然后在项目中创建符号链接，这样可以避免重复下载和安装相同的包。
  - `pnpm` 也使用锁文件（`pnpm-lock.yaml`），确保依赖的一致性。

### 2. **磁盘空间占用**

- **npm**
  - 早期版本的 `npm` 会递归安装所有依赖，导致 `node_modules` 目录非常大，占用大量磁盘空间。
  - 新版本的 `npm` 通过扁平化安装（`npm@3` 及以上）减少了磁盘空间占用，但仍然不如 `pnpm`。
- **yarn**
  - `yarn` 通过缓存机制减少了磁盘空间占用，但每个项目仍然有自己的 `node_modules` 目录，可能会导致一些重复的包。
- **pnpm**
  - `pnpm` 通过全局存储和符号链接机制，显著减少了磁盘空间占用。所有依赖只存储一次，项目中只是创建符号链接，因此磁盘空间占用最小。

### 3. **依赖一致性**

- **npm**
  - `npm` 使用 `package-lock.json` 文件来确保依赖的一致性。从 `npm@5` 开始，`package-lock.json` 文件会自动生成，确保所有开发者在项目中使用相同的依赖版本。
  - 但 `npm` 的依赖解析机制可能导致一些版本差异，特别是在复杂的依赖树中。
- **yarn**
  - `yarn` 使用 `yarn.lock` 文件来确保依赖的一致性。`yarn.lock` 文件会精确记录每个依赖的版本，确保所有开发者在项目中使用相同的依赖版本。
  - `yarn` 的依赖解析机制非常严格，确保依赖的一致性。
- **pnpm**
  - `pnpm` 使用 `pnpm-lock.yaml` 文件来确保依赖的一致性。`pnpm-lock.yaml` 文件会精确记录每个依赖的版本，确保所有开发者在项目中使用相同的依赖版本。
  - `pnpm` 的依赖解析机制也非常严格，确保依赖的一致性。

### 4. **性能**

- **npm**
  - 新版本的 `npm` 性能有所提升，但仍然不如 `yarn` 和 `pnpm`。
  - `npm` 的安装速度和磁盘空间占用在多项目环境下表现不佳。
- **yarn**
  - `yarn` 的并行安装和缓存机制使其在安装速度和磁盘空间占用方面表现优异。
  - `yarn` 的性能在多项目环境下表现良好，但仍然不如 `pnpm`。
- **pnpm**
  - `pnpm` 的硬链接和符号链接机制使其在安装速度和磁盘空间占用方面表现最佳。
  - `pnpm` 的性能在多项目环境下表现优异，特别是在大型项目中。

### 5. **生态系统和社区支持**

- **npm**
  - `npm` 是最古老的包管理工具，拥有最广泛的生态系统和社区支持。
  - 大多数 JavaScript 项目和开发者都使用 `npm`，因此在查找和使用包时非常方便。
- **yarn**
  - `yarn` 由 Facebook 开发，近年来获得了广泛的关注和使用。
  - `yarn` 的社区支持也非常强大，许多大型项目（如 React）推荐使用 `yarn`。
- **pnpm**
  - `pnpm` 是相对较新的包管理工具，但近年来发展迅速。
  - `pnpm` 的社区支持在逐渐增长，特别是在大型项目和企业环境中，其性能和磁盘空间优化优势使其受到欢迎。

### 总结

- **npm**：历史悠久，生态系统和社区支持强大，但性能和磁盘空间占用方面表现一般。
- **yarn**：安装速度快，性能优异，社区支持强大，但磁盘空间占用仍有一定改进空间。
- **pnpm**：安装速度快，磁盘空间占用最小，性能优异，社区支持逐渐增长，特别适合大型项目和多项目环境。

选择哪个包管理工具取决于你的具体需求和项目规模。如果你在大型项目中对性能和磁盘空间优化有较高要求，`pnpm` 可能是最佳选择。如果你更注重社区支持和生态系统，`npm` 和 `yarn` 也是不错的选择。