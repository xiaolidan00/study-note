# http 状态码

**分类：**

- 1xx 服务器收到请求
- 2xx 请求成功
- 3xx 重定向
- 4xx 客户端错误
- 5xx 服务端错误

**常见状态码：**

200 成功

301 永久重定向（配合 location，浏览器自动处理）

302 临时重定向（配合 location，浏览器自动处理）

304 资源未被修改

404 资源未找到

403 没有权限

500 服务器错误

504 网关超时

# https

1. 客户端请求 url 地址
2. 服务器（存有 CA 数字证书，公钥 A,私钥 B,颁发机构，公司信息，域名，有效期)
3. 响应请求，会携带数字证书（证书保护公钥 A)
4. 客户端解析证书，验证合法性(不合法提示 https 警告)，合法则去除公钥 A,并生成随机码 KEY，使用公钥 A 加密随机码 KEY（非对称加密）
5. 客户端吧加密后的随机码 KEY 发送给服务器，作为接下来的对称加密的秘钥
6. 服务器使用私钥 B 解密得到随机码 KEY,再使用随机码 KEY 对传输数据进行对称加密（对称加密）
7. 传输对称加密后的内容给客户端
8. 客户端使用之前生成的随机码 KEY 解密数据
9. 通过对称加密传输所有内容

**简化过程**

1. 服务端证书
2. 客户端校验
3. 客户端校验通过，生成随机数，RSA 公钥加密，消息体摘要 MD5 加密=》RAS 签名
4. 服务端 RSA 私钥解密=》随机数，AES 加密作为密钥（服务端与客户端）

消息体摘要 MD5:防止篡改，消息的完整性

## HTTP 与 HTTPS 区别

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

# http 缓存

静态资源缓存（js,css,img)
webpack 打包文件 hash

**强制缓存**

Response Headers 中
控制强制缓存逻辑

Cache-Control:max-age=31536000(单位秒)
最大的缓存时间为一年

过程：

- 初次请求->服务器->返回资源和 Cache-Control 到浏览器
- 再次请求->本地缓存（判断 Cache-Control 是否过期）->返回资源
- 缓存失效->再次请求服务器->返回资源和 Cache-Control 到浏览器

- max-age 缓存时间
- no-cache 不需强制缓存，交给服务端处理
- no-store 不需要本地和服务端的缓存

Expires 同为控制缓存过期，已被 Cache-Control 代替

**协商缓存（对比缓存）**

- 服务端缓存策略
- 服务器判断客户端资源是否与服务端一致
- 一致则返回 304（资源未被修改，读取浏览器缓存），否则返回 200 和最新资源

**协商缓存过程：**

- 初次请求服务器=》返回资源和资源标识
- 再次请求，带着资源标识=》返回 304 或返回资源和最新资源

**区别**

- Last-Modified 资源最后修改的时间
- ETag 资源的唯一标识（一个字符串，类似人类指纹）

**Last-Modified 过程：**

- 初次请求服务器-》返回资源和 Last-Modified
- 再次请求，Request Headers 带着 If-Modified-Since（之前的 Last-Modified 的值）=>返回 304，或最新资源和新 Last-Modified

**Etag 过程：**

- 初次请求服务器-》返回资源和 Etag
- 再次请求，Request Headers 带着 If-None-Math(之前的 Etag)->返回 304，或新资源和新 Etag

- 优先使用 Etag
- Last-Modified 只能精确到秒
- 如果资源被重复生成，而内容不变，则 Etag 更精确

**三种刷新操作**

- 正常操作：地址栏输入 URL，跳转链接=》强制缓存有效，协商缓存有效
- 手动刷新：F5,右键菜单栏=》强制缓存失效，协商缓存有效
- 强制刷新：ctrl+F5=》强制缓存和协商缓存失效

# 浏览器渲染过程

1. dns 域名解析，得到实际的 ip 地址，浏览器 -- 本地 hosts -- 本地域名服务器（递归查找） -- 根域名服务器（迭代查找）
2. 检查浏览器是否有缓存：

- Cache-Control 和 Expires 来检查是否命中强缓存，命中则直接取本地磁盘的 html（状态码为 200 from disk(or memory) cache，内存 or 磁盘）；
- 没有命中强缓存，则会向服务器发起请求（先进行下一步的 TCP 连接），服务器通过 Etag 和 Last-Modify 来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；

3. 建立 TCP 连接，三次握手，如果协议是 https，还需要做加密；
4. 浏览器发送请求获取页面 html；
5. 服务器响应 html；
6. 浏览器解析 html；
   - 渲染进程解析 HTML,生成 DOM 树（深度遍历）
   - 解析 HTML 的同时，如果遇到内联样式和样式脚本，则下载并生成 CSS 样式规则，遇到 js 则下载该脚本
   - DOM 树和 CSS 样式规则书构建完成后，渲染进程将两者合并成渲染树（Render Tree）
   - 渲染进程开始对渲染树进行布局，生成布局树(Layout Tree)
   - 渲染进程对布局树进行绘制，显示到页面中

**注意：**

- 遇到 css，不会阻塞 DOM 树的解析，但会阻塞 DOM 树的渲染，并会阻塞 js 执行。
- 遇到 js，会阻塞 DOM 树的解析，所以 js 要放在下面或者异步加载。defer 或 async。

# Web 攻击与防范手段

1. **XSS（跨站脚本攻击）**：

   - 非持久型 XSS（反射型 XSS）：通过 URL 传递恶意脚本代码。
   - 持久型 XSS（存储型 XSS）：通过表单提交等方式将恶意脚本保存到服务器，然后执行。
   - 防御措施：对用户输入进行转义处理，确保服务器端和客户端都不直接执行用户输入的脚本。

2. **CSRF（跨站请求伪造）**：

   - 攻击者利用用户的登录状态，伪造请求执行恶意操作。
   - 防御措施：使用 CSRF 令牌，验证请求的合法性。

3. **SQL 注入**：

   - 攻击者通过构造恶意 SQL 语句，获取数据库信息或执行其他操作。
   - 防御措施：使用参数化查询，限制数据库操作权限，对输入进行验证和转义。

4. **命令行注入**：

   - 攻击者通过 HTTP 请求执行系统命令。
   - 防御措施：对用户输入进行严格的验证和转义，不直接拼接命令行。

5. **DDoS（分布式拒绝服务）攻击**：

   - 通过大量请求使服务器资源过载，导致服务不可用。
   - 防御措施：优化网络架构，使用负载均衡，限制请求频率，使用专业的 DDoS 防御设备。

6. **流量劫持**：

   - 包括 DNS 劫持和 HTTP 劫持，篡改用户请求的内容。
   - 防御措施：使用 HTTPS 加密通信，防止内容被篡改。

7. **服务器漏洞**：
   - 如越权操作、目录遍历、物理路径泄漏等。
   - 防御措施：合理设计数据库表结构，对 URL 和参数进行转义过滤，定制错误页面。

# 跨域

**服务器端设置**

- nginx 代理转发
- CORS 服务器设置 http headers

```js
//允许跨域的设置
Access-Control-Allow-Origin:http://localhost:8080
Access-Controll-Allow-Headers:X-Requested-With
Access-Controll-Allow-Methods:"PUT,POST,GET,DELETE,OPTIONS"

//接收跨域cookie
Access-Controll-Allow-Credentials:true
```

**前端设置跨域**

- devServer 设置 proxy
- document.domain 修改访问域
- jsonp
